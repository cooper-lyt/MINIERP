package com.dgsoft.erp.model;
// Generated Oct 1, 2013 5:41:32 PM by Hibernate Tools 4.0.0

import com.dgsoft.common.TotalDataGroup;
import com.dgsoft.erp.model.api.StoreResCountTotalGroup;
import com.dgsoft.erp.total.SameFormatResGroupStrategy;
import com.dgsoft.erp.total.StoreResGroupStrategy;
import org.apache.xmlbeans.impl.xb.xsdschema.All;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.util.*;

/**
 * StockChange generated by hbm2java
 */
@Entity
@Table(name = "STOCK_CHANGE", catalog = "MINI_ERP")
public class StockChange implements Comparable<StockChange>, java.io.Serializable {

    @Override
    @Transient
    public int compareTo(StockChange o) {
        return getOperDate().compareTo(o.getOperDate());
    }

    public enum StoreChangeType {
        MATERIAL_IN(EnumSet.of(ResCategory.ResType.MATERIAL, ResCategory.ResType.OUTER_MATERIAL), false),
        MATERIAL_BACK_IN(EnumSet.of(ResCategory.ResType.MATERIAL, ResCategory.ResType.OUTER_MATERIAL), false),
        MATERIAL_OUT(EnumSet.of(ResCategory.ResType.MATERIAL, ResCategory.ResType.OUTER_MATERIAL), true),
        SELL_OUT(EnumSet.of(ResCategory.ResType.PRODUCT, ResCategory.ResType.FITTING), true),
        SELL_BACK(EnumSet.of(ResCategory.ResType.PRODUCT, ResCategory.ResType.FITTING), false),
        PRODUCE_IN(EnumSet.of(ResCategory.ResType.PRODUCT, ResCategory.ResType.FITTING, ResCategory.ResType.SEMI_PRODUCT, ResCategory.ResType.WORK_IN_PROCESS), false),
        ALLOCATION_IN(EnumSet.allOf(ResCategory.ResType.class), false),
        ALLOCATION_OUT(EnumSet.allOf(ResCategory.ResType.class), true),
        ASSEMBLY_IN(EnumSet.allOf(ResCategory.ResType.class), false),
        ASSEMBLY_OUT(EnumSet.allOf(ResCategory.ResType.class), true),
        SCRAP_OUT(EnumSet.allOf(ResCategory.ResType.class), true),
        STORE_CHECK_LOSS(EnumSet.allOf(ResCategory.ResType.class), true),
        STORE_CHECK_ADD(EnumSet.allOf(ResCategory.ResType.class), false),
        STORE_CHANGE_IN(EnumSet.allOf(ResCategory.ResType.class), false),
        STORE_CHANGE_OUT(EnumSet.allOf(ResCategory.ResType.class), true);

        private EnumSet<ResCategory.ResType> resTypes;

        private boolean out;

        public EnumSet<ResCategory.ResType> getResTypes() {
            return resTypes;
        }


        public boolean isOut() {
            return out;
        }

        public static EnumSet<StoreChangeType> getAllOut(){
             return EnumSet.of(MATERIAL_OUT,SELL_OUT,ALLOCATION_OUT,ASSEMBLY_OUT,SCRAP_OUT,STORE_CHECK_LOSS,STORE_CHANGE_OUT);
        }

        public static EnumSet<StoreChangeType> getAllIn(){
            return EnumSet.of(MATERIAL_IN,MATERIAL_BACK_IN,SELL_BACK,PRODUCE_IN,ALLOCATION_IN,ASSEMBLY_IN,STORE_CHECK_ADD,STORE_CHANGE_IN);
        }

        private StoreChangeType(EnumSet<ResCategory.ResType> resTypes, boolean out) {
            this.resTypes = resTypes;
            this.out = out;
        }
    }

    private String id;
    private Store store;
    private Date operDate;
    private String operEmp;
    private StoreChangeType operType;
    private String memo;
    private boolean verify;

    private Inventory inventory;
    private Allocation allocation;
    private Assembly assembly;

    private Set<StockChangeItem> stockChangeItems = new HashSet<StockChangeItem>(0);
    private Set<PrepareStockChange> prepareStockChanges = new HashSet<PrepareStockChange>(0);

    public StockChange() {
    }

    public StockChange(boolean verify) {
        this.verify = verify;
    }


    public StockChange(Store store, String operEmp,
                       StoreChangeType operType, boolean verify) {
        this.store = store;
        this.operEmp = operEmp;
        this.operType = operType;
        this.verify = verify;
    }

    public StockChange(Store store, Date operDate, String operEmp,
                       StoreChangeType operType, String memo, boolean verify) {
        this.store = store;
        this.operDate = operDate;
        this.operEmp = operEmp;
        this.operType = operType;
        this.memo = memo;
        this.verify = verify;
    }

    public StockChange(String id, Store store, Date operDate, String operEmp,
                       StoreChangeType operType, String memo, boolean verify) {
        this(store, operDate, operEmp, operType, memo, verify);
        this.id = id;
    }

    @Id
    @Column(name = "ID", unique = true, nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @Column(name = "VERIFY", nullable = false)
    public boolean isVerify() {
        return verify;
    }

    public void setVerify(boolean verify) {
        this.verify = verify;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "STORE", nullable = false)
    @NotNull
    public Store getStore() {
        return this.store;
    }

    public void setStore(Store store) {
        this.store = store;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "OPER_DATE", nullable = false, length = 19)
    @NotNull
    public Date getOperDate() {
        return this.operDate;
    }

    public void setOperDate(Date operDate) {
        this.operDate = operDate;
    }

    @Column(name = "OPER_EMP", nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getOperEmp() {
        return this.operEmp;
    }

    public void setOperEmp(String operEmp) {
        this.operEmp = operEmp;
    }


    @Enumerated(EnumType.STRING)
    @Column(name = "OPER_TYPE", nullable = false, length = 32)
    @NotNull
    public StoreChangeType getOperType() {
        return this.operType;
    }

    public void setOperType(StoreChangeType operType) {
        this.operType = operType;
    }

    @Column(name = "MEMO", length = 200)
    @Size(max = 200)
    public String getMemo() {
        return this.memo;
    }

    public void setMemo(String memo) {
        this.memo = memo;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange", orphanRemoval = true, cascade = {CascadeType.ALL})
    public Set<StockChangeItem> getStockChangeItems() {
        return this.stockChangeItems;
    }

    public void setStockChangeItems(Set<StockChangeItem> stockChangeItems) {
        this.stockChangeItems = stockChangeItems;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange", orphanRemoval = true, cascade = {CascadeType.ALL})
    public Set<PrepareStockChange> getPrepareStockChanges() {
        return prepareStockChanges;
    }

    public void setPrepareStockChanges(Set<PrepareStockChange> prepareStockChanges) {
        this.prepareStockChanges = prepareStockChanges;
    }

    @Transient
    public List<TotalDataGroup<Res,StockChangeItem>> getStockChangeGroup(){
        return TotalDataGroup.groupBy(getStockChangeItems(),new StoreResGroupStrategy<StockChangeItem>(), new SameFormatResGroupStrategy<StockChangeItem>());
    }

    @Transient
    public StoreResCountTotalGroup getChangeDetails() {
        return new StoreResCountTotalGroup(getStockChangeItems());
    }

    @Transient
    public List<PrepareStockChange> getPrepareStockChangeList() {
        List<PrepareStockChange> result = new ArrayList<PrepareStockChange>(getPrepareStockChanges());
        Collections.sort(result, new Comparator<PrepareStockChange>() {
                    @Override
                    public int compare(PrepareStockChange o1, PrepareStockChange o2) {
                        return o1.getStoreRes().compareTo(o2.getStoreRes());
                    }
                }
        );
        return result;
    }

    @Transient
    public List<StockChangeItem> getStockChangeItemList() {
        List<StockChangeItem> result = new ArrayList<StockChangeItem>(getStockChangeItems());
        Collections.sort(result, new Comparator<StockChangeItem>() {
            @Override
            public int compare(StockChangeItem o1, StockChangeItem o2) {
                return o1.getStoreRes().compareTo(o2.getStoreRes());
            }
        });
        return result;
    }

    @ManyToOne(fetch = FetchType.LAZY,optional = false)
    @JoinColumn(name = "ASSEMBLY",nullable = true)
    public Assembly getAssembly() {
        return assembly;
    }

    public void setAssembly(Assembly assembly) {
        this.assembly = assembly;
    }

    private Set<ProductStoreIn> productStoreIns = new HashSet<ProductStoreIn>(0);

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<ProductStoreIn> getProductStoreIns() {
        return productStoreIns;
    }

    public void setProductStoreIns(Set<ProductStoreIn> productStoreIns) {
        this.productStoreIns = productStoreIns;
    }


    private Set<MaterialStoreOut> materialStoreOuts = new HashSet<MaterialStoreOut>(0);

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<MaterialStoreOut> getMaterialStoreOuts() {
        return materialStoreOuts;
    }

    public void setMaterialStoreOuts(Set<MaterialStoreOut> materialStoreOuts) {
        this.materialStoreOuts = materialStoreOuts;
    }



    private Set<MaterialStoreIn> materialStoreIns = new HashSet<MaterialStoreIn>(0);

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<MaterialStoreIn> getMaterialStoreIns() {
        return materialStoreIns;
    }

    public void setMaterialStoreIns(Set<MaterialStoreIn> materialStoreIns) {
        this.materialStoreIns = materialStoreIns;
    }


    private Set<ScrapStoreOut> scrapStoreOuts = new HashSet<ScrapStoreOut>(0);
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<ScrapStoreOut> getScrapStoreOuts() {
        return scrapStoreOuts;
    }

    public void setScrapStoreOuts(Set<ScrapStoreOut> scrapStoreOuts) {
        this.scrapStoreOuts = scrapStoreOuts;
    }


    private Set<BackDispatch> backDispatchs = new HashSet<BackDispatch>(0);
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<BackDispatch> getBackDispatchs() {
        return backDispatchs;
    }

    public void setBackDispatchs(Set<BackDispatch> backDispatchs) {
        this.backDispatchs = backDispatchs;
    }


    private Set<MaterialBackStoreIn> materialBackStoreIns = new HashSet<MaterialBackStoreIn>(0);

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<MaterialBackStoreIn> getMaterialBackStoreIns() {
        return materialBackStoreIns;
    }

    public void setMaterialBackStoreIns(Set<MaterialBackStoreIn> materialBackStoreIns) {
        this.materialBackStoreIns = materialBackStoreIns;
    }


    private Set<StoreChange> storeChanges = new HashSet<StoreChange>(0);
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<StoreChange> getStoreChanges() {
        return storeChanges;
    }

    public void setStoreChanges(Set<StoreChange> storeChanges) {
        this.storeChanges = storeChanges;
    }


    private Set<Dispatch> orderDispatchs = new HashSet<Dispatch>(0);

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "stockChange")
    public Set<Dispatch> getOrderDispatchs() {
        return orderDispatchs;
    }

    public void setOrderDispatchs(Set<Dispatch> orderDispatchs) {
        this.orderDispatchs = orderDispatchs;
    }

    @Transient
    public ProductStoreIn getProductStoreIn() {
        return getProductStoreIns().isEmpty() ? null : getProductStoreIns().iterator().next();
    }

    public void setProductStoreIn(ProductStoreIn productStoreIn) {
        getProductStoreIns().clear();
        getProductStoreIns().add(productStoreIn);
    }

    @Transient
    public MaterialStoreOut getMaterialStoreOut() {
        return getMaterialStoreOuts().isEmpty() ? null : getMaterialStoreOuts().iterator().next();
    }

    public void setMaterialStoreOut(MaterialStoreOut materialStoreOut) {
        getMaterialStoreOuts().clear();
        getMaterialStoreOuts().add(materialStoreOut);
    }

    @ManyToOne(fetch = FetchType.LAZY,optional = true)
    @JoinColumn(name = "ALLOCATION",nullable = true)
    public Allocation getAllocation() {
        return allocation;
    }

    public void setAllocation(Allocation allocation) {
        this.allocation = allocation;
    }

    @Transient
    public MaterialStoreIn getMaterialStoreIn() {
        return getMaterialStoreIns().isEmpty() ? null : getMaterialStoreIns().iterator().next();
    }

    public void setMaterialStoreIn(MaterialStoreIn materialStoreIn) {
        getMaterialStoreIns().clear();
        getMaterialStoreIns().add(materialStoreIn);
    }

    @ManyToOne(fetch = FetchType.LAZY,optional = true)
    @JoinColumn(name = "INVENTORY",nullable = true)
    public Inventory getInventory() {
        return this.inventory;
    }

    public void setInventory(Inventory inventory) {
        this.inventory = inventory;
    }

    @Transient
    public ScrapStoreOut getScrapStoreOut() {
        return getScrapStoreOuts().isEmpty() ? null : getScrapStoreOuts().iterator().next();
    }

    public void setScrapStoreOut(ScrapStoreOut scrapStoreOut) {
        getScrapStoreOuts().clear();
        getScrapStoreOuts().add(scrapStoreOut);
    }


    @Transient
    public BackDispatch getBackDispatch() {
        return getBackDispatchs().isEmpty() ? null : getBackDispatchs().iterator().next();
    }

    public void setBackDispatch(BackDispatch backDispatch) {
        getBackDispatchs().clear();
        getBackDispatchs().add(backDispatch);
    }

    @Transient
    public MaterialBackStoreIn getMaterialBackStoreIn() {
        return getMaterialBackStoreIns().isEmpty() ? null : getMaterialBackStoreIns().iterator().next();
    }

    public void setMaterialBackStoreIn(MaterialBackStoreIn materialBackStoreIn) {
        getMaterialBackStoreIns().clear();
        getMaterialBackStoreIns().add(materialBackStoreIn);
    }

    @Transient
    public Dispatch getOrderDispatch() {
        return getOrderDispatchs().isEmpty() ? null : getOrderDispatchs().iterator().next();
    }

    public void setOrderDispatch(Dispatch orderStoreOuts) {
        getOrderDispatchs().clear();
        getOrderDispatchs().add(orderStoreOuts);
    }

    @Transient
    public StoreChange getStoreChange() {
        return getStoreChanges().isEmpty() ? null : getStoreChanges().iterator().next();
    }

    public void setStoreChange(StoreChange storeChange) {
        getStoreChanges().clear();
        getStoreChanges().add(storeChange);
    }
}

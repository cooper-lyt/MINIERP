package com.dgsoft.erp.model;
// Generated Oct 17, 2013 5:33:51 PM by Hibernate Tools 4.0.0

import com.dgsoft.common.TotalDataGroup;
import com.dgsoft.erp.total.ResFormatGroupStrategy;
import com.dgsoft.erp.total.data.ResCount;
import com.dgsoft.erp.total.data.ResTotalCount;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.util.*;

/**
 * Allocation generated by hbm2java
 */
@Entity
@Table(name = "ALLOCATION", catalog = "MINI_ERP")
public class Allocation implements java.io.Serializable {

    public enum AllocationType{
        ALLOCATION_APPLY,ALLOCATION;
    }

    public enum AllocationState{
        WAITING_OUT,WAITING_IN,ALLOCATION_COMPLETE,ALLOCATION_CANCEL;
    }

    private String id;
    private Store inStore;
    private Store outStore;
    private String applyEmp;
    private String reason;
    private String memo;
    private AllocationState state;
    private AllocationType type;
    private Date createDate;
    private Set<AllocationRes> allocationReses = new HashSet<AllocationRes>(0);
    private Set<StockChange> stockChanges = new HashSet<StockChange>(0);
    public Allocation() {
    }

    public Allocation(String id, Store inStore,
                      Store outStore, String applyEmp, String reason,
                      AllocationState state, Date createDate) {
        this.id = id;
        this.inStore = inStore;
        this.outStore = outStore;
        this.applyEmp = applyEmp;
        this.reason = reason;
        this.state = state;
        this.createDate = createDate;
    }


    @Id
    @Column(name = "ID", unique = true, nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TARGET_STORE", nullable = false)
    @NotNull
    public Store getInStore() {
        return this.inStore;
    }

    public void setInStore(Store storeByTargetStore) {
        this.inStore = storeByTargetStore;
    }


    @OneToMany(fetch = FetchType.LAZY, mappedBy = "allocation", orphanRemoval = true,cascade = {CascadeType.PERSIST,CascadeType.REMOVE})
    public Set<StockChange> getStockChanges() {
        return stockChanges;
    }

    public void setStockChanges(Set<StockChange> stockChanges) {
        this.stockChanges = stockChanges;
    }

    @Transient
    public StockChange getStockChangeByStoreIn() {
        for(StockChange change: getStockChanges()){
            if (change.getOperType().equals(StockChange.StoreChangeType.ALLOCATION_IN)){
                return change;
            }
        }
        return null;
    }

    public void setStockChangeByStoreIn(StockChange stockChangeByStoreIn) {

        if (!StockChange.StoreChangeType.ALLOCATION_IN.equals(stockChangeByStoreIn.getOperType())){
            throw new IllegalArgumentException("type must be ALLOCATION_IN");
        }
        for(StockChange change: getStockChanges()){
            if (change.getOperType().equals(StockChange.StoreChangeType.ALLOCATION_IN)){
                getStockChanges().remove(change);
            }
        }
        getStockChanges().add(stockChangeByStoreIn);
    }

    @Transient
    public StockChange getStockChangeByStoreOut() {
        for(StockChange change: getStockChanges()){
            if (change.getOperType().equals(StockChange.StoreChangeType.ALLOCATION_OUT)){
                return change;
            }
        }
        return null;
    }

    public void setStockChangeByStoreOut(StockChange stockChangeByStoreOut) {
        if (!StockChange.StoreChangeType.ALLOCATION_OUT.equals(stockChangeByStoreOut.getOperType())){
            throw new IllegalArgumentException("type must be ALLOCATION_IN");
        }
        for(StockChange change: getStockChanges()){
            if (change.getOperType().equals(StockChange.StoreChangeType.ALLOCATION_OUT)){
                getStockChanges().remove(change);
            }
        }
        getStockChanges().add(stockChangeByStoreOut);
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "APPLY_STORE", nullable = false)
    @NotNull
    public Store getOutStore() {
        return this.outStore;
    }

    public void setOutStore(Store storeByApplyStore) {
        this.outStore = storeByApplyStore;
    }



    @Column(name = "APPLY_EMP", nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getApplyEmp() {
        return this.applyEmp;
    }

    public void setApplyEmp(String applyEmp) {
        this.applyEmp = applyEmp;
    }

    @Column(name = "REASON", nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getReason() {
        return this.reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }

    @Column(name = "MEMO", length = 200)
    @Size(max = 200)
    public String getMemo() {
        return this.memo;
    }

    public void setMemo(String memo) {
        this.memo = memo;
    }

    @Enumerated(EnumType.STRING)
    @Column(name = "STATE", nullable = false, length = 20)
    @NotNull
    public AllocationState getState() {
        return this.state;
    }

    public void setState(AllocationState state) {
        this.state = state;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "CREATE_DATE", nullable = false, length = 19, columnDefinition = "DATETIME")
    @NotNull
    public Date getCreateDate() {
        return this.createDate;
    }

    public void setCreateDate(Date createDate) {
        this.createDate = createDate;
    }

    @OneToMany(orphanRemoval = true,fetch = FetchType.LAZY, mappedBy = "allocation",cascade = {CascadeType.ALL})
    public Set<AllocationRes> getAllocationReses() {
        return this.allocationReses;
    }

    public void setAllocationReses(Set<AllocationRes> allocationReses) {
        this.allocationReses = allocationReses;
    }

    @Transient
    public List<TotalDataGroup<Res,AllocationRes,ResCount>> getAllocationResGroup(){
        return TotalDataGroup.groupBy(getAllocationReses(),new ResTotalCount.ResCountGroupStrategy<AllocationRes>(), new ResTotalCount.FormatCountGroupStrategy<AllocationRes>());
    }

    @Enumerated(EnumType.STRING)
    @Column(name = "TYPE", nullable = false, length = 32)
    @NotNull
    public AllocationType getType() {
        return type;
    }

    public void setType(AllocationType type) {
        this.type = type;
    }
}

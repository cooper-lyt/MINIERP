package com.dgsoft.erp.model;
// Generated Nov 5, 2013 1:58:21 PM by Hibernate Tools 4.0.0

import com.dgsoft.common.NamedEntity;
import com.dgsoft.common.utils.finance.Account;
import com.dgsoft.common.utils.persistence.UniqueVerify;
import com.google.common.collect.Iterators;
import org.jboss.seam.international.StatusMessage;
import sun.reflect.generics.tree.Tree;

import javax.persistence.*;
import javax.swing.tree.TreeNode;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.util.*;

/**
 * Accounting generated by hbm2java
 */
@Entity
@Table(name = "ACCOUNTING", catalog = "MINI_ERP")
@UniqueVerify(name = "Name", severity = StatusMessage.Severity.WARN, field = {"name"})
@NamedQuery(name = "findAccountingByName", query = "select accounting from Accounting accounting where accounting.name=:name")
public class Accounting implements java.io.Serializable, NamedEntity,Account {


    private String id;
    private Accounting accounting;
    private String accountingType;
    private String name;
    private String currency;
    private Account.Direction direction;
    private int level;
    private Res res;
    private Set<Accounting> accountings = new HashSet<Accounting>(0);
    private Set<OrderFee> orderFeesForDebit = new HashSet<OrderFee>(0);
    private Set<OrderFee> orderFeesForCredit = new HashSet<OrderFee>(0);

    public Accounting() {
    }


    @Id
    @Column(name = "ID", unique = true, nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PARENT")
    public Accounting getAccounting() {
        return this.accounting;
    }

    public void setAccounting(Accounting accounting) {
        this.accounting = accounting;
    }

    @Override
    @Transient
    public Account getParent(){
        if (isRoot()) {
            return null;
        } else {
            return getAccounting();
        }
    }

    @Column(name = "TYPE", nullable = false, length = 32)
    @Size(max = 32)
    @NotNull
    public String getAccountingType() {
        return this.accountingType;
    }

    public void setAccountingType(String accountingType) {
        this.accountingType = accountingType;
    }

    @Override
    @Column(name = "NAME", nullable = false, length = 50)
    @NotNull
    @Size(max = 50)
    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name = "CURRENCY", nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getCurrency() {
        return this.currency;
    }

    public void setCurrency(String currency) {
        this.currency = currency;
    }

    @Override
    @Transient
    public String getAccountCode() {
        return getId();
    }

    @Override
    @Enumerated(EnumType.STRING)
    @Column(name = "DIRECTION", nullable = false, length = 10)
    @NotNull
    public Account.Direction getDirection() {
        return this.direction;
    }

    public void setDirection(Account.Direction directoin) {
        this.direction = directoin;
    }

    @Override
    @Column(name="LEVEL", nullable = false)
    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "debitAccounting")
    public Set<OrderFee> getOrderFeesForDebit() {
        return orderFeesForDebit;
    }

    public void setOrderFeesForDebit(Set<OrderFee> orderFeesForDebit) {
        this.orderFeesForDebit = orderFeesForDebit;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "creditAccounting")
    public Set<OrderFee> getOrderFeesForCredit() {
        return orderFeesForCredit;
    }

    public void setOrderFeesForCredit(Set<OrderFee> orderFeesForCredit) {
        this.orderFeesForCredit = orderFeesForCredit;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "accounting")
    public Set<Accounting> getAccountings() {
        return this.accountings;
    }

    public void setAccountings(Set<Accounting> accountings) {
        this.accountings = accountings;
    }

    @OneToOne(optional = true, fetch = FetchType.LAZY, mappedBy = "accounting")
    public Res getRes() {
        return res;
    }

    public void setRes(Res res) {
        this.res = res;
    }

    @Transient
    public String getPathName(){
        if (isRoot()){
            return getName();
        }else{
            return getAccounting().getPathName() + " > " + getName();
        }
    }

    @Transient
    public List<Accounting> getAccountingList() {
        List<Accounting> result = new ArrayList<Accounting>(getAccountings());
        Collections.sort(result, new Comparator<Accounting>() {
            @Override
            public int compare(Accounting o1, Accounting o2) {
                if ((o1.getId() != null) && (o2.getId() != null)) {
                return o1.getId().compareTo(o2.getId());
                }else return 0;
            }
        });
        return result;
    }

    private List<TreeNode> childs = new ArrayList<TreeNode>();

    @Transient
    public List<TreeNode> getChilds() {
         if (getAccountings().isEmpty()){
             List<TreeNode> result = new ArrayList<TreeNode>();
             for (Accounting ac: getAccountingList()){
                 result.add(ac);
             }
             return result;
         }else{
             return childs;
         }

    }

    public void setChilds(List<TreeNode> childs) {
        if (!getAccountings().isEmpty()){
            throw new IllegalArgumentException("not leaf accounting can't set!");
        }
        this.childs = childs;
    }

    @Transient
    public boolean isRoot(){
        return getLevel() == 1;
    }

    @Transient
    public void setRoot(boolean root){
       if (root){
           setLevel(1);
       }else if (getAccounting() != null){
           setLevel(getAccounting().getLevel() + 1);
       }else{
           setLevel(-1);
       }
    }

    @Override
    @Transient
    public TreeNode getChildAt(int childIndex) {
        return getChilds().get(childIndex);
    }

    @Override
    @Transient
    public int getChildCount() {
        return getChilds().size();
    }

    @Override
    @Transient
    public int getIndex(TreeNode node) {
        return getChilds().indexOf(node);
    }

    @Override
    @Transient
    public boolean getAllowsChildren() {
        return true;
    }

    @Override
    @Transient
    public boolean isLeaf() {
        return getChilds().isEmpty();
    }

    @Override
    @Transient
    public Enumeration children() {
        return Iterators.asEnumeration(getChilds().iterator());
    }
}

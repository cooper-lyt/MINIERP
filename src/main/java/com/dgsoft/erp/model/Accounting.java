package com.dgsoft.erp.model;
// Generated Nov 5, 2013 1:58:21 PM by Hibernate Tools 4.0.0

import com.dgsoft.common.NamedEntity;
import com.dgsoft.common.utils.persistence.UniqueVerify;
import com.google.common.collect.Iterators;
import org.jboss.seam.international.StatusMessage;

import javax.persistence.*;
import javax.swing.tree.TreeNode;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.util.*;

/**
 * Accounting generated by hbm2java
 */
@Entity
@Table(name = "ACCOUNTING", catalog = "MINI_ERP")
@UniqueVerify(name = "Name", severity = StatusMessage.Severity.WARN, field = {"name"})
@NamedQuery(name = "findAccountingByName", query = "select accounting from Accounting accounting where accounting.name=:name")
public class Accounting implements java.io.Serializable, TreeNode, NamedEntity {

    public enum Direction {
        CREDIT, DBEDIT;
    }

    private String id;
    private Accounting accounting;
    private String accountingType;
    private String name;
    private String currency;
    private Direction direction;
    private boolean root;
    private Res res;
    private Set<AccountOper> accountOpersForDebitAccount = new HashSet<AccountOper>(0);
    private Set<Accounting> accountings = new HashSet<Accounting>(0);
    private Set<AccountOper> accountOpersForCreditAccount = new HashSet<AccountOper>(0);
    private Set<OrderFee> orderFeesForDebit = new HashSet<OrderFee>(0);
    private Set<OrderFee> orderFeesForCredit = new HashSet<OrderFee>(0);

    public Accounting() {
    }


    @Id
    @Column(name = "ID", unique = true, nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PARENT")
    public Accounting getAccounting() {
        return this.accounting;
    }

    public void setAccounting(Accounting accounting) {
        this.accounting = accounting;
    }


    @Column(name = "TYPE", nullable = false, length = 32)
    @Size(max = 32)
    @NotNull
    public String getAccountingType() {
        return this.accountingType;
    }

    public void setAccountingType(String accountingType) {
        this.accountingType = accountingType;
    }

    @Column(name = "NAME", nullable = false, length = 50)
    @NotNull
    @Size(max = 50)
    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name = "CURRENCY", nullable = false, length = 32)
    @NotNull
    @Size(max = 32)
    public String getCurrency() {
        return this.currency;
    }

    public void setCurrency(String currency) {
        this.currency = currency;
    }

    @Enumerated(EnumType.STRING)
    @Column(name = "DIRECTION", nullable = false, length = 10)
    @NotNull
    public Direction getDirection() {
        return this.direction;
    }

    public void setDirection(Direction directoin) {
        this.direction = directoin;
    }

    @Column(name = "ROOT", nullable = false)
    public boolean isRoot() {
        return this.root;
    }

    public void setRoot(boolean root) {
        this.root = root;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "debitAccounting")
    public Set<OrderFee> getOrderFeesForDebit() {
        return orderFeesForDebit;
    }

    public void setOrderFeesForDebit(Set<OrderFee> orderFeesForDebit) {
        this.orderFeesForDebit = orderFeesForDebit;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "creditAccounting")
    public Set<OrderFee> getOrderFeesForCredit() {
        return orderFeesForCredit;
    }

    public void setOrderFeesForCredit(Set<OrderFee> orderFeesForCredit) {
        this.orderFeesForCredit = orderFeesForCredit;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "accounting")
    public Set<Accounting> getAccountings() {
        return this.accountings;
    }

    public void setAccountings(Set<Accounting> accountings) {
        this.accountings = accountings;
    }

    @OneToOne(optional = true, fetch = FetchType.LAZY, mappedBy = "accounting")
    public Res getRes() {
        return res;
    }

    public void setRes(Res res) {
        this.res = res;
    }

    @Transient
    public List<Accounting> getAccountingList() {
        List<Accounting> result = new ArrayList<Accounting>(getAccountings());
        Collections.sort(result, new Comparator<Accounting>() {
            @Override
            public int compare(Accounting o1, Accounting o2) {
                if ((o1.getId() != null) && (o2.getId() != null)) {
                return o1.getId().compareTo(o2.getId());
                }else return 0;
            }
        });
        return result;
    }

    @Override
    @Transient
    public TreeNode getChildAt(int childIndex) {
        return getAccountingList().get(childIndex);
    }

    @Override
    @Transient
    public int getChildCount() {
        return getAccountings().size();
    }

    @Override
    @Transient
    public TreeNode getParent() {
        if (isRoot()) {
            return null;
        } else {
            return getAccounting();
        }
    }

    @Override
    @Transient
    public int getIndex(TreeNode node) {
        return getAccountingList().indexOf(node);
    }

    @Override
    @Transient
    public boolean getAllowsChildren() {
        return true;
    }

    @Override
    @Transient
    public boolean isLeaf() {
        return getAccountings().isEmpty();
    }

    @Override
    @Transient
    public Enumeration children() {
        return Iterators.asEnumeration(getAccountingList().iterator());
    }
}
